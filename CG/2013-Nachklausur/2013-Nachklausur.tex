\documentclass[a4paper]{scrartcl}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage{graphicx}
\usepackage[inline]{enumitem}
\setlist{noitemsep}
\usepackage[binary-units=true]{siunitx}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage[nameinlink,noabbrev,ngerman]{cleveref} % has to be after hyperref
\usepackage{nicefrac}  % for \nicefrac{1}{3}
\usepackage{csquotes}  % for \enquote{what you want to quote}
\usepackage{booktabs}  % for \toprule, \midrule and \bottomrule
\usepackage{minted} % needed for the inclusion of source code
\usepackage{pgfplots}
\usepackage{tikz}

% for \begin{enumerate}[label=(\Alph*)], see http://tex.stackexchange.com/a/129960/5645
\usepackage{enumitem}

\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}

\usepackage{wasysym}  % For \CheckedBox
\usepackage{microtype}

\begin{document}
\selectlanguage{ngerman}
\title{2013 Nachklausur (WS 2012/13)}

\setcounter{section}{1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Aufgabe 1: Raytracing}
\subsection*{Teilaufgabe 1a}
\begin{figure}[h]
    \centering
    \includegraphics*[width=0.8\linewidth, keepaspectratio]{1a.png}
    \caption{Reflexionsstrahl, Schattenstrahlen und Transmissionstrahl}
    \label{fig:1a}
\end{figure}

\subsection*{Teilaufgabe 1b}
\textit{Wie nennt man das physikalische Gesetz oder Prinzip, welches die Richtungsänderung
eines Lichtstrahls beim Übergang in ein anderes Medium beschreibt?}

Snellsches Gesetz ($\eta_0 \cdot \sin \theta_0 = \theta_1 \cdot \sin \delta_1$)

\subsection*{Teilaufgabe 1c}
\textit{Welche Bedingung muss gelten, damit beim Übergang eines Lichtstrahls
von einem Medium mit Refraktionsindex $\eta_0$ in ein Medium mit
Refraktionsindex $\eta_1$ Totalreflexion auftreten kann?}

Der Einfallswinkel muss einen Grenzwinkel
$\theta = \arcsin \frac{\eta_1}{\eta_0}$
überschreiten (also besonders flach auf das Material sein).


\section*{Aufgabe 2: Beleuchtung und Wahrnehmung}
\subsection*{Teilaufgabe 2a}
\begin{itemize}
    \item Bild 1: Nicht mögliche Kombination aus Bild~2 und Bild~3.
    \item Bild 2: Nur spekular (glossy)
    \item Bild 3: Entspricht einem Glanzlicht in Richtung $N$, aber das ist nur
                  in Richtung $R_L$ möglich.
    \item Bild 4: Komplett diffus.
\end{itemize}

\subsection*{Teilaufgabe 2b}
\begin{tabular}{p{12cm}ll}\toprule
Aussage                                                                                                                                                           & Wahr           & Falsch \\\midrule
Von den drei Grundfarben der additiven Farbmischung sind Menschen gegenüber blau in der Regel am unempfindlichsten.                                               & \CheckedBox    & $\square$        \\
Es gibt keine zwei unterschiedlichen Lichtspektren im sichtbaren Bereich, die der Mensch als dieselbe Farbe wahrnimmt.                                            & $\square$      & \CheckedBox      \\
Genau drei Grundgrößen reichen (nach Graßmann) aus, um einen menschlichen Farbeindruck zu beschreiben.                                                            & \CheckedBox    & $\square$        \\
Es entspricht nicht der menschlichen Farbempfindlichkeit, wenn die Helligkeit (Luminanz) einer Farbe als das arithmetische Mittel der RGB-Anteile berechnet wird. & \CheckedBox    & $\square$        \\
Gammakorrektur mit dem Parameter $\gamma$ wird üblicherweise durch die Abbildung $L'=\gamma^L$ beschrieben.                                                       & $\square$      & \CheckedBox      \\\bottomrule
\end{tabular}

\section*{Aufgabe 3: Transformationen}
\subsection*{Teilaufgabe 3a}
Homogene Koordinaten
\[M = \begin{pmatrix}1 & 0 & 2\\
                     0 & 2 & 1\\
                     0 & 0 & 1\end{pmatrix}\]

\subsection*{Teilaufgabe 3b}
\textit{Geben Sie zeichnerisch ein einfaches Beispiel an, das deutlich zeigt,
dass man die Normalen eines Primitivs im Allgemeinen nicht mit derselben Matrix
transformieren kann wie die Vertizes. Um was für eine Art Transformation
handelt es sich dabei?}

Normale auf Kreis; Skalierung in $x$-Richtung.

\subsection*{Teilaufgabe 3c}
\textit{Um Normalen korrekt von Objekt- in Kamerakoordinaten zu transformieren, verwendet man die\dots}
\begin{itemize}
    \item \CheckedBox inverstransponierte Model-View-Matrix.
    \item $\square$ dehomogenisierte Model-View-Matrix.
    \item $\square$ inverse Projektionsmatrix.
\end{itemize}

\textit{Die Matrix $\begin{pmatrix}1 & 0 & 2\\
                     0 & 1 & 2\\
                     0 & 0 & 1\end{pmatrix}$ ist eine\dots}
\begin{itemize}
    \item \CheckedBox Translationsmatrix in homogenen 2D-Koordinaten.
    \item $\square$ Translationsmatrix in homogenen 3D-Koordinaten.
    \item $\square$ Rotationsmatrix in $\mathbb{R}^{3 \times 3}$.
\end{itemize}

\textit{Die Matrix $\begin{pmatrix}0 & 1\\
                     1 & 0\end{pmatrix}$ beschreibt eine\dots}
\begin{itemize}
    \item $\square$ Rotation.
    \item \CheckedBox Spiegelung an der ersten Winkelhalbierenden.
    \item $\square$ nichtlineare Abbildung.
\end{itemize}

Matrixmultiplikation ist stets kommutativ, wenn\dots
\begin{itemize}
    \item \CheckedBox nur Skalierungsmatrizen multipliziert werden.
    \item $\square$ nur Scherungsmatrizen multipliziert werden.
    \item $\square$ nur Rotationsmatrizen multipliziert werden.
\end{itemize}

2D-Rotationsmatrizen sind kommutativ:
\begin{align}
    \begin{pmatrix}\cos \alpha & -\sin \alpha\\
                   \sin \alpha & \cos \alpha\end{pmatrix} \cdot
    \begin{pmatrix}\cos \beta & -\sin \beta\\
                   \sin \beta & \cos \beta\end{pmatrix}
    &= \begin{pmatrix}\cos \alpha \cos \beta - \sin  \alpha \sin \beta & -\cos \alpha \sin \beta - \sin \alpha \cos \beta\\
                      \sin \alpha \cos \beta + \cos \alpha \sin \beta  & -\sin \alpha \sin \beta + \cos \alpha \cos \beta\end{pmatrix}\\
    &=\begin{pmatrix}\cos \beta & -\sin \beta\\
                   \sin \beta & \cos \beta\end{pmatrix} \cdot \begin{pmatrix}\cos \alpha & -\sin \alpha\\
                   \sin \alpha & \cos \alpha\end{pmatrix}
\end{align}

3D-Rotationsmatrizen nicht:
\begin{align}
R_x(\frac{3}{2}\pi) \cdot R_z(\frac{3}{2}\pi)
&= \begin{pmatrix}1 & 0 & 0\\ 0 & 0 & 1\\0 & -1 & 0\end{pmatrix} \cdot
  \begin{pmatrix}0 & 1 & 0\\-1 & 0 & 0\\0 &  0 & 1\end{pmatrix} \\
 &=
  \begin{pmatrix}0 & 1 & 0\\ 0 & 0 & 1\\1 &  0 & 0\end{pmatrix} \neq
  \begin{pmatrix}0 & 0 & 1\\-1 & 0 & 0\\0 & -1 & 0\end{pmatrix} \\
 &=
  \begin{pmatrix}0 & 1 & 0\\-1 & 0 & 0\\0 &  0 & 1\end{pmatrix} \cdot
  \begin{pmatrix}1 & 0 & 0\\ 0 & 0 & 1\\0 & -1 & 0\end{pmatrix} \\
 &= R_z(\frac{3}{2}\pi) \cdot R_x(\frac{3}{2}\pi)
\end{align}

\section*{Aufgabe 4: Texturen und Texture-Mapping}
\subsection*{Teilaufgabe 4a}
\textit{Skizzieren Sie hier die Ausgabe}

Für die $t$-Koordinate ist \texttt{GL\_CLAMP} eingestellt. Das bedeutet, dass
nach oben die letzte Texel-Reihe einfach wiederholt wird und nach unten die
erste Texel-Reihe wiederholt wird.

Für die $s$-Koordinate ist \texttt{GL\_REPEAT} eingestellt. Das bedeutet, dass
nach rechts und links die komplette Textur nochmals hinkopiert wird.

Damit ergibt sich das Gesamtbild:\\
\begin{tikzpicture}
    \begin{axis}[
        legend pos=south west,
        axis x line=middle,
        axis y line=middle,
        grid = major,
        %width=9cm,
        %height=4.5cm,
        grid style={dashed, gray!30},
        xmin=-1.25,     % start the diagram at this x-coordinate
        xmax= 1.25,    % end   the diagram at this x-coordinate
        ymin=-0.75,     % start the diagram at this y-coordinate
        ymax= 1.75,   % end   the diagram at this y-coordinate
        axis background/.style={fill=white},
        xlabel=$s$,
        ylabel=$t$,
        %xticklabels={-2,-1.6,...,7},
        %yticklabels={-8,-7,...,8},
        tick align=outside,
        minor tick num=-3,
        enlargelimits=true,
        tension=0.08]

      \draw[fill=black!25] (axis cs:0.0,-.7) rectangle (axis cs:0.5,0.5) node[pos=.5] {C};
      \draw[fill=white]    (axis cs:0.5,-.7) rectangle (axis cs:1.0,0.5) node[pos=.5] {D};
      \draw[fill=white]    (axis cs:0.0,0.5) rectangle (axis cs:0.5,1.7) node[pos=.5] {A};
      \draw[fill=black!25] (axis cs:0.5,0.5) rectangle (axis cs:1.0,1.7) node[pos=.5] {B};
      \draw[fill=black!25] (axis cs:1.0,-.7) rectangle (axis cs:1.5,0.5) node[pos=.5] {C};
      \draw[fill=white]    (axis cs:1.0,0.5) rectangle (axis cs:1.5,1.7) node[pos=.5] {A};
      \draw[fill=black!25] (axis cs:-0.5,0.5) rectangle (axis cs:0.0,1.7) node[pos=.5] {B};
      \draw[fill=white]    (axis cs:-0.5,-.7) rectangle (axis cs:0.0,0.5) node[pos=.5] {D};
      \draw[fill=black!25] (axis cs:-0.5,-.7) rectangle (axis cs:-1.0,0.5) node[pos=.5] {C};
      \draw[fill=white]    (axis cs:-0.5,0.5) rectangle (axis cs:-1.0,1.7) node[pos=.5] {A};
      \draw[fill=black!25] (axis cs:-1.5,0.5) rectangle (axis cs:-1.0,1.7) node[pos=.5] {B};
      \draw[fill=white]    (axis cs:-1.5,-.7) rectangle (axis cs:-1.0,0.5) node[pos=.5] {D};

    \end{axis}
    \begin{axis}[
        axis x line=middle,
        axis y line=middle,
        grid = major,
        grid style={dashed, gray!30},
        xmin=-1.25,     % start the diagram at this x-coordinate
        xmax= 1.25,    % end   the diagram at this x-coordinate
        ymin=-0.75,     % start the diagram at this y-coordinate
        ymax= 1.75,   % end   the diagram at this y-coordinate
        xlabel=$s$,
        ylabel=$t$,
        %xticklabels={-2,-1.6,...,7},
        %yticklabels={-8,-7,...,8},
        tick align=outside,
        minor tick num=-3,
        enlargelimits=true,
        tension=0.08]
      \draw[red,thick] (axis cs:-0.5,-.5) rectangle (axis cs:1,1.5) node[pos=.5] {};

      \node[label={180:{1}},circle,fill,inner sep=2pt] at (axis cs:-0.5,-0.5) {};
      \node[label={180:{2}},circle,fill,inner sep=2pt] at (axis cs:1,-0.5) {};
      \node[label={180:{3}},circle,fill,inner sep=2pt] at (axis cs:1,1.5) {};
      \node[label={180:{4}},circle,fill,inner sep=2pt] at (axis cs:-0.5,1.5) {};
    \end{axis}
\end{tikzpicture}

\subsection*{Teilaufgabe 4b}
\textit{Wann und wofür wird die bilineare Interpolation beim Texture-Mapping verwendet?}

Bei Magnification um Unschärfe zu kompensieren.

\subsection*{Teilaufgabe 4c}
\textit{Was ist die Grundidee von vorgefilterten Environment Maps?}

Die Grundidee ist die Darstellung einer Umgebung mit nur geringem Aufwand.

\textit{Nennen Sie zwei Beispiele für Beleuchtungseffekte, die damit erzielt werden können!}

\begin{itemize}
    \item Diffuse Beleuchtung
    \item Spekulare Beleuchtung
\end{itemize}


\textit{Welche grundlegende Annahme wird dabei gemacht?}

Die Umgebung ist weit genug entfernt, sodass die Position keine Rolle spielt
und nur die Richtung genommen werden muss.

\section*{Aufgabe 5: Räumliche Datenstrukturen}
\subsection*{Teilaufgabe 5a}
\begin{tabular}{p{9cm}llll}\toprule
Aussage                                                                                                                    & BVH & Octree & kD-Baum & Gitter \\\midrule
Die Raumunterteilung kann mit Hilfe der Surface Area Heuristic durchgeführt werden.                                        & \CheckedBox   & $\square$        & \CheckedBox       & $\square$        \\
Die Anzahl der Schnitttests mit Primitiven kann durch Mailboxing weiter reduziert werden.                                  & \CheckedBox   & \CheckedBox      & $\square$         & \CheckedBox      \\
Die Raumunterteilung ist geschickt für Szenen mit einer Geometrie, die dem sogenannten Teapot-in-a-Stadium-Problem ähnelt. & \CheckedBox   & \CheckedBox      & \CheckedBox       & $\square$        \\
Der Datenstruktur liegt ein Binärbaum zugrunde.                                                                            & \CheckedBox   & $\square$        & \CheckedBox       & $\square$        \\\bottomrule
\end{tabular}
\subsection*{Teilaufgabe 5b}
\includegraphics*[width=0.8\linewidth, keepaspectratio]{5b.png}

\subsection*{Teilaufgabe 5c}
\textit{Sie wollen in der obigen Szene Raytracing durchführen und dies mit einer räumlichen
Datenstuktur beschleunigen. Ist dafür ein regelmäßiges Gitter oder ein kD-Baum besser
geeignet? Begründen Sie Ihre Entscheidung!}

Ein kD-Baum eignet sich für das genannte Szenario besser, da bei Verwendung
eines Gitters mehr als die Hälfte des raumes leer ist. Der Großteil der
Geometrie befindet sich links unten.

\section*{Aufgabe 6: Rauschen und Turbulenz}
\subsection*{Teilaufgabe 6a}
\textit{Welche der Funktionen ist eine Rauschfunktion (value noise)?}
$\gamma(t)$

\subsection*{Teilaufgabe 6b}
\textit{Welche der Funktionen ist eine Turbulenzfunktion? Wie kann man eine Turbulenz-
funktion aus einer Rauschfunktion wie der aus Aufgabe a) erzeugen? Geben Sie eine
Formel an!}

$\delta(t)$ wird erzeugt durch spektrale Synthese (vgl. Folie~14):

\[\text{turbulence}(x) = \sum{k}^n (\nicefrac{1}{2})^k \cdot n(2^k \cdot x)\]

\subsection*{Teilaufgabe 6c}
\textit{Welche zwei der Funktionen sind weder Rausch- noch Turbulenzfunktionen?
Nennen Sie jeweils eine Eigenschaft von Rauschfunktionen, die nicht erfüllt
wird.}

\begin{itemize}
    \item[$\alpha$] Eine Rauschfunktion darf nicht sichtbar periodisch sein
    \item[$\beta$] Räumliche Korrelation ist verletzt
\end{itemize}

\section*{Aufgabe 7: Interpolation}
\subsection*{Teilaufgabe 7a}
\textit{Wie berechnet man die baryzentrische Koordinate $\lambda_2$ des Punktes $\mathbf{x}$ bezüglich des
abgebildeten Rechtecks?}

\[\lambda_2 = \frac{\square(\mathbf{x}, \mathbf{x}_4)}{\square(\mathbf{x}_1, \mathbf{x}_3)}\]

\subsection*{Teilaufgabe 7b}
\textit{Berechnen Sie anhand der in der Zeichnung angegeben Längen die 4 baryzentrischen
Koordinaten des Punktes $\mathbf{x}$ mit der Formel aus Aufgabenteil a). Nutzen Sie dann
die baryzentrischen Koordinaten, um anzugeben, wie der interpolierte Farbwert $\mathbf{c}$ am
Punkt $\mathbf{x}$ berechnet wird.}

\begin{align}
    \lambda_1 &= \nicefrac{2}{9}  & \lambda_2 &= \nicefrac{1}{9}\\
    \lambda_3 &= \nicefrac{2}{9}  & \lambda_4 &= \nicefrac{4}{9}
\end{align}

\[c = \nicefrac{2}{9} \cdot c_1 + \nicefrac{1}{9} \cdot c_2 + \nicefrac{2}{9} \cdot c_3 + \nicefrac{4}{9} \cdot c_4\]

\subsection*{Teilaufgabe 7c}
\begin{align}
    \lambda_1^\Delta &= \nicefrac{1}{3}  & \lambda_3^\Delta &= \nicefrac{1}{3}\\
    \lambda_4^\Delta &= \nicefrac{1}{3}
\end{align}

\[c' = \nicefrac{1}{3} \cdot c_1 + \nicefrac{1}{3} \cdot c_3 + \nicefrac{1}{3} \cdot c_4 \neq c\]

\section*{Aufgabe 8: OpenGL und OpenGL-Shader}
\begin{tabular}{cp{8cm}cc}\toprule
    ~  & Aussage                                                                                                                  & Wahr & Falsch \\\midrule
    1  & Beleuchtung mit Schattenberechnung kann bei OpenGL mit Hilfe von \texttt{glEnable(GL\_LIGHTING | GL\_SHADOWS)} aktiviert werden.  & \CheckedBox    & $\square$        \\
    2  & Der Vertex-Cache funktioniert nicht mit indizierten Vertizes.                                                            & $\square$      & \CheckedBox      \\
    3  & Im Fragment-Shader kann auf benachbarte Fragmente zugegriffen werden.                                                    & $\square$      & \CheckedBox      \\
    4  & Im Fragment-Shader kann man die Tiefe eines Fragments verändern.                                                         & \CheckedBox    & $\square$        \\
    5  & Die Fixed-Function-Pipeline berechnet Beleuchtung in normalisierten Gerätekoordinaten.                                   & $\square$      & \CheckedBox      \\
    6  & OpenGL führt Clipping in normalisierten Gerätekoordinaten durch.                                                         & $\square$      & \CheckedBox      \\
    7  & Der Maler-Algorithmus benutzt einen Tiefenpuffer, um das Sichtbarkeitsproblem zu lösen.                                  & $\square$      & \CheckedBox      \\
    8  & Im Vertex-Shader kann man durch Erzeugung zusätzlicher Vertizes Primitive unterteilen.                                   & $\square$      & \CheckedBox      \\
    9  & Der Fragment-Shader ist in der OpenGL-Pipeline vor den Fragment-Operationen und nach dem Geometrie-Shader.               & \CheckedBox    & $\square$        \\
    10 & Beim Tiefenpuffer-Verfahren ist die Reihenfolge des Zeichnens auch bei opaken Primitiven wichtig für die Korrektheit.    & $\square$      & \CheckedBox      \\\bottomrule
\end{tabular}

\clearpage
\section*{Aufgabe 9: Toon-Shading in OpenGL}
\subsection*{Teilaufgabe 9a}
\inputminted[linenos, numbersep=5pt, tabsize=4, frame=lines, label=shader9a.vert]{glsl}{shader9a.vert}

\subsection*{Teilaufgabe 9b}
\textit{Berechnen Sie im folgenden Fragment-Shader den Richtungsvektor zur Lichtquelle.
Berechnen Sie dann aus dem Winkel zwischen Lichtrichtung und Normale den passenden Winkelbereich \texttt{c} und nutzen Sie \texttt{toonShade(int c)}, um die Ausgabefarbe zu
bestimmen. Speichern Sie diese in \texttt{color}.}
\inputminted[linenos, numbersep=5pt, tabsize=4, frame=lines, label=shader9b.frag]{glsl}{shader9b.frag}

\clearpage
\section*{Aufgabe 10: Clipping in einem OpenGL-Shader}
\subsection*{Teilaufgabe 10a}
\inputminted[linenos, numbersep=5pt, tabsize=4, frame=lines, label=shader10a.vert]{glsl}{shader10a.vert}

\subsection*{Teilaufgabe 10b}
\inputminted[linenos, numbersep=5pt, tabsize=4, frame=lines, label=shader10b.frag]{glsl}{shader10b.frag}

\clearpage
\section*{Aufgabe 11: OpenGL und semitransparente Kugeln}
\subsection*{Teilaufgabe 11.1}
\inputminted[linenos, numbersep=5pt, tabsize=4, frame=lines, label=opengl.cpp]{cpp}{opengl.cpp}

\subsection*{Teilaufgabe 11.2}
\textit{Begründen Sie kurz warum Sie die Funktion \texttt{sort( spheres )} benutzt oder nicht
benutzt haben.}

Da die Sphären alle semi-transparent sind (nicht-kommuntativer
Blendingoperator) müssen sie von hinten nach vorne gezeichnet werden um
korrekt dargestellt zu werden.

\subsection*{Teilaufgabe 11.3}
\textit{Begründen Sie kurz warum Sie die Funktion \textit{sortPrim( sphere )} benutzt
oder nicht benutzt haben.}

Analog zu (11.2).

\subsection*{Teilaufgabe 11.4}
\begin{tabular}{cp{8cm}lll}\toprule
~ & Aussage                                                                                                                                                          &
 Wahr & Falsch & Begründung \\\midrule
1 & Um eine Szene mit opaken und semitransparenten Objek-ten mit OpenGL möglichst korrekt zu zeichnen, muss man die opaken nach den transparenten Objekten zeichnen. &
 $\square$      & \CheckedBox   &   \\
2 & Der Alpha-Test erlaubt es, Fragmente anhand ihres Alpha-Wertes zu verwerfen, ohne den Tiefenpuffer zu modifizieren.                                              &
 \CheckedBox    & $\square$     &   \\
3 & Alpha-Clipping ist eine Fragmentoperation und findet zwischen Alpha-Test und Alpha-Blending statt.                                                               &
 $\square$      & \CheckedBox   &   \\
4 & Der Blendingoperator definiert durch \texttt{glBlendEquation(GL\_FUNC\_ADD)} und \texttt{glBlendFunc(GL\_SRC\_ALPHA, GL\_SRC\_ALPHA)} ist kommutativ.            &
 \CheckedBox    & $\square$     &  1) \\\bottomrule
\end{tabular}
\\[3pt]
1)
COLOR = SRC\_ALPHA $\cdot$ SRC\_COLOR + SRC\_ALPHA $\cdot$ DST\_COLOR $\Leftrightarrow$ \\
COLOR = SRC\_ALPHA $\cdot$ DST\_COLOR + SRC\_ALPHA $\cdot$ SRC\_COLOR

\section*{Aufgabe 12: Bézierkurven}
\subsection*{Teilaufgabe 12a}
\begin{tabular}{cp{10cm}cc}\toprule
    \# & Aussage                                                                                                        & Wahr        & Falsch \\\midrule
    1  & Bézierkurven liegen immer innerhalb der konvexen Hülle der Kontrollpunkte.                                     & \CheckedBox & $\square$ \\
    2  & Bézierkurven interpolieren zwei Ihrer Kontrollpunkte und approximieren alle anderen.                           & \CheckedBox & $\square$ \\
    3  & Um eine Bézierkurve affin zu transformieren, genügt es, die Transformation auf ihre Kontrollpunkte anzuwenden. & \CheckedBox & $\square$ \\
    4  & Bézierkurven sind stetig differenzierbar.                                                                      & \CheckedBox & $\square$ \\\bottomrule
\end{tabular}

\subsection*{Teilaufgabe 12b}
\begin{tabular}{cllp{8cm}}\toprule
Kurve & Ja           & Nein           & Begründung                                      \\\midrule
1     & $\square$    & \CheckedBox    & Kurve verlässt konvexe Hülle der Kontrollpunkte \\
2     & \CheckedBox  & $\square$      & ~                                               \\
3     & $\square$    & \CheckedBox    & Tangentenbedingung verletzt                     \\
4     & \CheckedBox  & $\square$      &                                                 \\\bottomrule
\end{tabular}

\end{document}
